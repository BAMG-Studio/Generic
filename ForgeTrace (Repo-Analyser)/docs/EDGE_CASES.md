# ForgeTrace Edge Case Handling Guide

This document describes how ForgeTrace handles common edge cases encountered in real-world repository audits.

## Table of Contents

1. [Monorepos](#monorepos)
2. [Generated Code](#generated-code)
3. [Minified/Uglified JavaScript](#minifieduglified-javascript)
4. [Database Migrations](#database-migrations)
5. [Git Submodules](#git-submodules)
6. [Legacy Code](#legacy-code-5-years-old)
7. [Vendored Dependencies](#vendored-dependencies)
8. [Mixed Language Files](#mixed-language-files)
9. [Binary Assets](#binary-assets)
10. [CI/CD Generated Artifacts](#cicd-generated-artifacts)

---

## 1. Monorepos

### Definition
Multiple projects or packages in a single repository.

### Examples
- Google's internal repository
- Babel, React Native
- Turborepo, Nx workspaces

### Detection Signals
- Multiple `package.json` files
- Multiple `setup.py` files
- Multiple `go.mod` files
- Project structure with `packages/`, `apps/`, `services/`

### ForgeTrace Handling

**Classification Strategy**:
- Detect project boundaries via manifest files
- Analyze each subproject independently
- Aggregate statistics at repository level
- Report IP breakdown per subproject

**Configuration**:
```yaml
# config.yaml
analysis:
  monorepo_detection: true
  subproject_roots:
    - "packages/"
    - "services/"
    - "apps/"
    - "modules/"
  separate_subproject_reports: false  # Set true for per-project reports
```

**CLI Usage**:
```bash
# Analyze entire monorepo
forgetrace audit /path/to/monorepo --out ./results

# Analyze specific subproject
forgetrace audit /path/to/monorepo/packages/core --out ./results/core
```

### Known Issues
- Shared dependencies counted multiple times in naive analysis
- Cross-package imports may skew authorship metrics

### Future Enhancements
- Dependency graph analysis across subprojects
- Shared code attribution

---

## 2. Generated Code

### Definition
Code automatically generated by tools (protobuf, GraphQL, Swagger, ORM).

### Examples
- `*_pb2.py` (Protocol Buffers)
- `*.generated.ts` (GraphQL Codegen)
- `schema.graphql` (GraphQL schemas)
- `api_client.py` (Swagger/OpenAPI)
- Alembic/Django migrations (partially generated)

### Detection Signals

**File Headers**:
```python
# AUTO-GENERATED FILE - DO NOT EDIT
# Generated by protoc 3.19.0
```

**File Patterns**:
- `*_pb2.py`, `*_pb2_grpc.py`
- `*.generated.ts`, `*.generated.js`
- `*_gen.go`
- `schema.graphql`

**Code Characteristics**:
- High `template_indicator` score (>0.8)
- Repetitive patterns
- Low cyclomatic complexity despite high LOC
- Few meaningful variable names

### ForgeTrace Handling

**Classification**:
- Generated by OSS tools â†’ `third_party`
- Generated by proprietary tools â†’ `foreground` (custom generator is IP)

**Feature Extraction**:
```python
# In ML classifier
features = {
    "has_autogen_header": 1.0,
    "file_pattern_generated": 1.0,
    "template_indicator": 0.95,
    "avg_identifier_length": 3.2,  # Short, obfuscated names
}
```

**Configuration**:
```yaml
# config.yaml
analysis:
  generated_code_detection: true
  generated_patterns:
    - "*_pb2.py"
    - "*.generated.*"
    - "*_gen.go"
  exclude_generated: false  # Set true to exclude from LOC counts
```

### Validation
```bash
# Check generated code classification
forgetrace audit /repo --out ./results --verbose

# Look for: "ðŸ” Detected generated file: schema_pb2.py (confidence: 0.98)"
```

---

## 3. Minified/Uglified JavaScript

### Definition
Compressed JavaScript with removed whitespace and obfuscated names.

### Examples
```javascript
// Minified
!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,...

// Original
function initializeApp(config) {
  const settings = parseConfig(config);
  return new Application(settings);
}
```

### Detection Signals
- Lines >1000 characters
- Variable names: `a`, `b`, `c`, `_0x1234`
- No comments or whitespace
- File size disproportionately large for line count

### ForgeTrace Handling

**Strategy 1: Extract Source Maps**
```bash
# Check for source maps
ls dist/*.js.map

# If available, analyze original source
forgetrace audit /repo/src --out ./results
```

**Strategy 2: Classify as Third-Party**
```python
# Automatic classification
if is_minified(file_content):
    classification = "third_party"
    confidence = 0.95
```

**Configuration**:
```yaml
# config.yaml
analysis:
  minified_detection: true
  minified_thresholds:
    max_line_length: 1000
    min_identifier_length: 2
    whitespace_ratio: 0.05  # <5% whitespace
  exclude_minified: true  # Exclude from analysis
```

### Recommendations
- Always audit source code, not built artifacts
- Ensure `.gitignore` excludes `dist/`, `build/`
- If only minified code available, flag for manual review

---

## 4. Database Migrations

### Definition
Schema evolution scripts (Alembic, Flyway, Liquibase, Django migrations).

### Examples

**Django**:
```python
# migrations/0001_initial.py
operations = [
    migrations.CreateModel(
        name='User',
        fields=[
            ('id', models.AutoField(primary_key=True)),
        ],
    ),
]
```

**Alembic**:
```python
# alembic/versions/abc123_add_users.py
def upgrade():
    op.create_table('users', ...)

def downgrade():
    op.drop_table('users')
```

### Detection Signals
- File paths: `migrations/`, `alembic/versions/`
- File patterns: `*_migration.py`, `V*.sql`
- Function names: `upgrade()`, `downgrade()`, `up()`, `down()`

### ForgeTrace Classification

**Auto-Generated Migrations** â†’ `third_party`
```bash
# Django auto-migrations
python manage.py makemigrations
# Alembic auto-migrations
alembic revision --autogenerate
```

**Custom Migration Logic** â†’ `foreground`
```python
# Custom data transformation
def upgrade():
    conn = op.get_bind()
    # Complex business logic (100+ lines)
    users = conn.execute("SELECT * FROM old_users")
    for user in users:
        transformed = custom_transform(user)  # Proprietary logic
        conn.execute("INSERT INTO new_users ...", transformed)
```

**Heuristic**:
- If migration <20 lines â†’ likely auto-generated â†’ `third_party`
- If migration >50 lines with complex logic â†’ `foreground`

### Configuration
```yaml
# config.yaml
analysis:
  migration_detection: true
  migration_paths:
    - "migrations/"
    - "alembic/versions/"
    - "db/migrate/"
  migration_complexity_threshold: 50  # LOC threshold
```

---

## 5. Git Submodules

### Definition
Nested Git repositories referenced in a parent repository.

### Detection
```bash
# Check for submodules
cat .gitmodules

# Example:
[submodule "vendor/lib"]
    path = vendor/lib
    url = https://github.com/external/lib.git
```

### ForgeTrace Handling

**Strategy 1: Classify as Third-Party**
```python
# Default behavior
if is_submodule(file_path):
    classification = "third_party"
```

**Strategy 2: Recursive Analysis** (optional)
```bash
# Analyze submodules separately
forgetrace audit /repo --analyze-submodules --out ./results

# Results:
# - results/main_repo/
# - results/vendor/lib/
```

**Configuration**:
```yaml
# config.yaml
analysis:
  submodule_detection: true
  analyze_submodules: false  # Set true for deep analysis
  submodule_classification: "third_party"  # or "ignore"
```

### Recommendations
- Clearly document submodule origins in audit report
- Flag proprietary submodules separately
- Consider submodule licenses in compliance review

---

## 6. Legacy Code (>5 Years Old)

### Definition
Code unchanged for extended periods (typically >5 years).

### Challenges
- May lack SPDX headers or license comments
- Original authors may have left organization
- License compliance unclear
- Git history may predate current repository

### ForgeTrace Handling

**Detection**:
```python
# Check last modification date
git log --follow --format="%ad" --date=short -- <file> | tail -1
# Example output: 2018-03-15 (7+ years old)
```

**Classification Strategy**:
```python
if last_modified > 5_years_ago:
    if has_license_header:
        classification = "third_party"  # Trust header
    else:
        # Increase confidence threshold for ML classifier
        if ml_confidence < 0.90:
            classification = "uncertain"
            flag_for_manual_review = True
```

**Configuration**:
```yaml
# config.yaml
analysis:
  legacy_threshold_years: 5
  legacy_handling: "flag_for_review"  # or "classify_as_third_party"
  legacy_confidence_threshold: 0.90  # Higher than default 0.70
```

### Recommendations
1. **Check Git Blame**:
   ```bash
   git blame --line-porcelain <file> | grep "^author "
   ```

2. **Search Commit Messages**:
   ```bash
   git log --all --oneline --grep="vendor" --grep="import" -- <file>
   ```

3. **Manual Review**: Flag uncertain legacy code for legal review

---

## 7. Vendored Dependencies

### Definition
Third-party libraries copied directly into repository (not via package manager).

### Examples
- `vendor/jquery-3.5.1.js`
- `third_party/requests/`
- Embedded copies of open-source libraries

### Detection Signals
- Directories: `vendor/`, `third_party/`, `lib/external/`
- License files: `vendor/LICENSE`, `vendor/README.md`
- README references: "Includes vendored copy of X"

### ForgeTrace Handling

**Configuration**:
```yaml
# config.yaml
analysis:
  vendored_paths:
    - "vendor/"
    - "third_party/"
    - "lib/external/"
    - "deps/"
  auto_classify_vendored: true  # Automatically mark as third_party
```

**License Detection**:
```bash
# ForgeTrace extracts licenses from vendored code
forgetrace audit /repo --out ./results --include-sbom

# Results include:
# - jquery-3.5.1.js: MIT License
# - requests/: Apache-2.0
```

### Recommendations
- Always prefer package managers over vendoring
- Document vendored dependencies in `README.md`
- Keep vendored code in isolated directories

---

## 8. Mixed Language Files

### Definition
Single files containing multiple programming languages.

### Examples

**HTML with Embedded JavaScript/CSS**:
```html
<!DOCTYPE html>
<html>
<style>
  .header { color: blue; }  <!-- CSS -->
</style>
<script>
  function init() { ... }  // JavaScript
</script>
</html>
```

**Python with SQL**:
```python
query = """
    SELECT u.name, o.total
    FROM users u
    JOIN orders o ON u.id = o.user_id
    WHERE o.date > '2025-01-01'
"""
```

### ForgeTrace Handling

**Strategy**: Analyze by file extension (primary language)
```python
# HTML file with embedded JS
file_ext = ".html"
primary_language = "HTML"
# Analyze as HTML file, classify JS/CSS as part of file
```

**Limitations**:
- Cannot separate authorship of embedded languages
- License headers apply to entire file

### Future Enhancements
- Multi-language AST parsing
- Separate attribution for `<script>` blocks vs HTML structure

---

## 9. Binary Assets

### Definition
Non-text files (images, fonts, compiled libraries, media files).

### Examples
- Images: `logo.png`, `banner.jpg`
- Fonts: `Roboto.ttf`, `FontAwesome.woff2`
- Compiled: `library.so`, `app.exe`
- Media: `video.mp4`, `audio.mp3`

### ForgeTrace Handling

**Detection**:
```python
BINARY_EXTENSIONS = {
    '.png', '.jpg', '.jpeg', '.gif', '.svg',
    '.ttf', '.woff', '.woff2', '.eot',
    '.so', '.dll', '.exe', '.dylib',
    '.mp4', '.mp3', '.wav', '.avi',
    '.pdf', '.zip', '.tar.gz',
}
```

**Classification**:
- Stock images/fonts â†’ `third_party`
- Custom artwork â†’ `foreground`
- Compiled libraries â†’ Check source origin

**Analysis**:
```bash
# ForgeTrace skips binary analysis by default
# But includes in file count and size metrics

# Results:
# Total files: 1,234
# Binary files: 89 (7%)
# Total size: 45 MB (binaries: 32 MB)
```

### Recommendations
- Store large binaries in Git LFS
- Document binary asset licenses separately
- Consider excluding binaries from IP audit scope

---

## 10. CI/CD Generated Artifacts

### Definition
Files created during build/deployment (not committed to source control).

### Examples
- Build outputs: `dist/`, `build/`, `target/`
- Dependency locks: `package-lock.json`, `yarn.lock`, `Pipfile.lock`
- Cache files: `.pytest_cache/`, `node_modules/`, `__pycache__/`
- Coverage reports: `coverage.xml`, `htmlcov/`

### Detection
```bash
# Check .gitignore for excluded patterns
cat .gitignore | grep -E "dist/|build/|node_modules/"
```

### ForgeTrace Handling

**Default Behavior**: Respect `.gitignore`
```python
# Skip analysis of ignored files
if file in gitignore_patterns:
    skip_file = True
```

**Configuration**:
```yaml
# config.yaml
analysis:
  respect_gitignore: true
  exclude_build_artifacts: true
  artifact_patterns:
    - "dist/"
    - "build/"
    - "target/"
    - "node_modules/"
    - "__pycache__/"
```

### Validation
```bash
# Ensure artifacts are excluded
forgetrace audit /repo --out ./results --verbose

# Should see: "â„¹ï¸ Skipping ignored path: node_modules/"
```

---

## Client-Specific Profiling

### Collecting Client Characteristics

Use this questionnaire for new client engagements:

```yaml
# client_profile.yaml
client_name: "Example Corp"
repository_url: "https://github.com/example/repo"

characteristics:
  repo_type: "monorepo"  # monorepo | microservices | monolithic
  primary_languages: ["Python", "TypeScript", "Go"]
  
  code_generation:
    - type: "protobuf"
      tool: "protoc"
      patterns: ["*_pb2.py"]
    - type: "graphql"
      tool: "graphql-codegen"
      patterns: ["*.generated.ts"]
  
  dependencies:
    package_manager: "pip"
    total_direct: 45
    total_transitive: 230
    vendored: true
    vendored_paths: ["vendor/"]
  
  architecture:
    uses_submodules: false
    uses_git_lfs: true
    has_binary_assets: true
  
  edge_cases:
    - "minified_js_in_dist"
    - "django_migrations"
    - "vendored_jquery"
  
  known_issues:
    - "Mixed PHP/HTML in templates/"
    - "Legacy Perl scripts in scripts/"
```

### Profiling Dataset Management

```bash
# Create profiling dataset
python scripts/create_client_profile.py \
  --client "Example Corp" \
  --repo /path/to/client/repo \
  --output training/profiling_datasets/example_corp/

# Run benchmarks
pytest tests/performance/test_client_profiles.py -k example_corp

# Results:
# - Accuracy: 99.8%
# - Latency: 8ms/file
# - Memory: 320 MB
```

---

## Unsupported Edge Cases (Roadmap)

These scenarios require future development:

1. **Jupyter Notebooks**: Cell-level analysis needed
2. **Mixed Python/Cython**: C extensions require compilation
3. **Encrypted Files**: Cannot analyze without decryption key
4. **Extremely Large Files**: >100 MB files may timeout
5. **Non-UTF-8 Encodings**: Legacy encodings (Latin-1, etc.)

---

## Contributing Edge Case Handling

Found a new edge case? Please:

1. Document the scenario
2. Provide example repository (anonymized)
3. Describe expected vs actual behavior
4. Submit GitHub issue with label `edge-case`

---

**Last Updated**: 2025-11-16  
**Maintainer**: Peter Kolawole (peter@beaconagile.net)
